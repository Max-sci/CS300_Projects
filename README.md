# CS300_Projects
Project One and Project Two from SNHU CS-300

# What was the problem you were solving in the projects for this course?
In Project One, the goal was to analyze the efficiency of different data structures in terms of time and memory usage. This included comparing performance when inserting, accessing, and deleting elements. In Project Two, I developed a course planner system that reads data from a file and prints out a sorted list of Computer Science courses in alphanumeric order, which required efficient data storage and traversal strategies.

# How did you approach the problem? Consider why data structures are important to understand.
I started by selecting the most appropriate data structure for the problem—choosing between vectors, hash tables, and binary search trees—based on the trade-offs in time and space complexity. Understanding data structures is essential because they directly affect the speed and scalability of a program. For the sorting task, I used a Binary Search Tree (BST) to naturally store and retrieve the courses in order.

# How did you overcome any roadblocks you encountered while going through the activities or project?
One major challenge was managing dynamic memory allocation and pointers when building the BST in C++. I reviewed documentation, debugged with print statements, and leaned on logic diagrams to trace issues. I also used test cases to confirm that the tree maintained correct order and structure.

# How has your work on this project expanded your approach to designing software and developing programs?
This project reinforced the importance of planning before coding. I learned to think critically about the type of data I was handling and the best way to structure it for both efficiency and clarity. It also pushed me to consider how the system would scale with larger inputs, which is essential in real-world applications.

# How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
I made a conscious effort to use meaningful variable names, modular functions, and in-code comments to improve readability. By keeping my code clean and logically organized, I’ve learned how easier it becomes to troubleshoot and extend functionality later. These habits will help me write maintainable and professional-grade software going forward.

